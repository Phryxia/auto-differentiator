# 모델 원칙

모든 수식은 불변객체이다.

# Math-Parser 문법

평범한 수식의 문법이다.

- 연산자 우선순위는 괄호 → 부호연산(`+`, `-`) → 지수연산(`^`) → 곱셈/나눗셈(`*`, `/`) → 덧셈/뺄셈(`+`, `-`) 순이다.
- 지수연산끼리는 오른쪽에서 왼쪽으로 해석한다. (ex:` 2^2^2`는 `2^(2^2)`와 동일하다)
- 나머지 동일한 연산자 간에는 왼쪽에서 오른쪽으로 해석한다.

```ebnf
digit = "0" | "1" | ... | "9"
number_exp_part = "e" ["+" | "-"] {digit}
number = {digit} ["." [{digit} [number_exp_part]]]
       | "." {digit} [number_exp_part]
id = {"a" | "b" | ... | "z" | "A" | "B" | ... | "Z"}

expr = term
     | expr "+" term
term = expo
     | term "*" expo
expo = unit
     | unit "^" expo
unit = ["+" | "-"] leaf
leaf = number
     | id [["_" leaf] leaf]
     | "(" expr ")"
     | "{" expr "}"
     | "[" expr "]"
```

# 파서 원칙

## 경고(warning)

**경고(warning)**는 무시했을 때 해석을 하는데 지장이 없는 경우의 알림이다.

ex) 정의되지 않은 문자의 사용(ex: `#`), 가능한 모든 인식을 끝낸 후 토큰이 남은 경우(ex: `x*y 1`에서 `1`)

## 오류(error)

**오류(error)**는 해석이 불가능한 경우의 알림이다.

ex) non-terminal symbol 인식 도중 예상하지 않은 토큰(ex: `x * (y + )`에서 `)`)

## 공백은 무시하되, 공백에 의해 토큰은 구분된다.

ex) `123 456 x +` => `["123", "456", "x", "+"]`

## 문법에서 정의하지 않은 문자는 무시하며, 경고를 띄운다. 단, 이 문자에 의해 토큰은 구분된다.

ex) `a#b` => `["a", "b"]`

## 동일한 상수와 변수는 하나의 `Constant` 오브젝트를 레퍼런스로 갖는다.

성능 향상을 위해서이다.

# 수식 텍스트 렌더링 원칙

## 계산 트리를 왜곡없이 중위표현식으로 표현한다.

`x + y`와 `y + x`는 다르다. 수학적으로 동등하더라도 계산 트리가 다르기 때문이다.

## 위 항을 위배하지 않는다면 괄호의 사용을 최소화한다.

`explicitParenthesis: true` 옵션으로 괄호 최적화를 제외할 수 있다.

X: `(x * y) + (a + b) - 20`
O: `x * y + a + b - 20`

### 동일한 우선순위의 연산자 간에는 괄호 사용을 하지 않는다.

X: `a * (b * c)`
O: `a * b * c`

물론 괄호를 제거했을 때 의미가 바뀌는 경우는 제외한다. (ex: `a/(b/c)` ≠ `a/b/c`)

### 함수 호출문은 반드시 괄호를 사용한다.

X: `sin x`
O: `sin(x)`

## 불필요한 양의 부호연산은 제거한다.

X: `+(3 * x + 2)`
O: `3 * x + 2`

# 수식 최적화 원칙

최적화의 주된 목적은 계산 트리의 노드 수를 줄이는 것이다. 또한 렌더링 했을 때 사람이 인식하기 쉽게 하기 위함도 있다.

## 모든 최적화는 전후 결과가 수학적으로 동일해야 한다.

참고로 잠재적으로 0이 될 수 있는 식으로 나누는 행위는, 약분한 결과와 다르게 취급한다.

ex) `x / x` ≠ `1`

## 단말노드가 모두 상수(`Constant`)인 서브트리는 하나의 상수로 합친다.

명명된 상수(`NamedConstant`)는 해당사항이 없다.

ex) `2 * (4 + 3)` → `14`

## 계산 트리를 변형하여 위를 실현할 수 있는 경우, 그렇게 한다.

ex) `(2 * x) * (3 + 4)` → `x * (2 * (3 + 4))` → `x * 14`

## 최적화 결과를 렌더링할 때 상수가 가장 앞에 오도록 한다.

ex) `x * (2 + 3) * y + 1` → `1 + 5 * x * y`

## 항등원은 생략한다.

ex) `0 + x` → `x`, `1 * x` → `x`, `x ^ 1` → `x`

## 2회 이상 반복되는 **상수곱을 제외하면 수학적으로 동일한 식**의 덧셈과 뺄셈은 동류항으로 간주하여 통합한다.

ex) `x^2 + 5 * x * x` → `6 * x^2`

## 2회 이상 반복되는 **상수곱을 제외하면 수학적으로 동일한 식**의 곱셈과 나눗셈은, 지수법칙을 적용하여 통합한다.

ex) `5 * x * 2 * x^2` → `10 * x^3`

단, 전체 지수가 양수이면서 잠재적으로 0이 될 수 있는 식으로 나눌 경우, 분모가 반드시 보존되어야 하며 분모의 지수는 1이어야 한다.

ex) `2 * (x + 1) * (x + 1)^3 / (x + 1)` → `2 * (x + 1)^4 / (x + 1)`

## 음의 지수는 분수로 변환한다.

ex) `(x + 1)^{-0.5}` → `1/(x+1)^0.5`

## 인수분해는 최적화 대상이 아니다.

인수분해는 계산 트리의 노드 수를 줄일 수는 있으나, 수학적인 인사이트 도출을 방해할 수 있기 때문에 제외한다.

ex) `a * x + b * x` ≠ `(a + b) * x`

인수분해를 최적화 대상으로 두지 않는 또다른 이유는, 복수의 선택지가 존재할 수 있기 때문이기도 하다. 각각의 선택지가 나비효과처럼 나머지 최적화에 영향을 미치기 때문에, 전체 최적화 과정에 지대한 영향을 미칠 수 있고, 이것을 모두 계산하여 최적을 찾는 것에는 지수복잡도가 소요된다. 대체로 이 작업은 구현만 복잡하게 만들며 큰 의미가 없다.

ex) `a * b + b * c + c * a` → `b * (a + c) + c * a` vs `a * (b + c) + b * c`

## 지수법칙을 최대한 적용할 수 있으면 적용한다.

ex) `((x + 2)^2)^x` → `(x + 2)^(2 * x)`, `e^ln(x)` → `x`
